<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法笔记-翻转链表</title>
      <link href="/2024/04/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/04/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><blockquote><p>前言: 这题算是简单 双指针就能解决 这题倒是让我想起今天写节点编辑器的问题 策划要一个废话节点 废话说完回到废话头 一个树里还有好几个头 ，没办法 节点直接的连接不是双向的 也就是只有上一个节点持有下一个节点 我只能让每个废话节点都要有根节点的引用……</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><div class="img-item" data-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" data-sub-html=".caption"><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">img</span></div></div></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><div class="img-item" data-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" data-sub-html=".caption"><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">img</span></div></div></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p></blockquote><p>? 还要递归 递归又容易爆栈又容易错  去tm的 递归都给爷爬  不写递归！（好好好 晚点写 晚点写）</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public ListNode next;</span></span><br><span class="line"><span class="comment"> *     public ListNode(int val=0, ListNode next=null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.next = next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span>(<span class="params">ListNode head</span>)</span> &#123;</span><br><span class="line">        ListNode pre = <span class="literal">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// //只有一个头结点 这里考虑错了 应为链表可能为空</span></span><br><span class="line">        <span class="comment">// if(cur.next == null) &#123;</span></span><br><span class="line">        <span class="comment">//     return head;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//需要保存一个temp 记录cur.next</span></span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在边界考虑的时候有点考虑多余了 忘记了 还有可能出现空链表的情况。</p><p>感觉笔记得算是日记了  毕竟每天都得逼自己记！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-股票问题</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-存在重复元素</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-设计链表</title>
      <link href="/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><blockquote><p>前言：4号 提交了5次全部失败 这里贴一下失败的尝试，设计链表非常考研程序整体的结构 一个方法出现纰漏 ，后面会出现各种问题。</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul></blockquote><h4 id="失败代码"><a href="#失败代码" class="headerlink" title="失败代码"></a>失败代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyLinkedNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> MyLinkedNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyLinkedList</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//虚假头节点</span></span><br><span class="line">        <span class="keyword">public</span> MyLinkedNode StartHead;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            StartHead = <span class="keyword">new</span> MyLinkedNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从头结点开始遍历</span></span><br><span class="line">            MyLinkedNode curNode = StartHead.next;</span><br><span class="line">            <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (curNode != <span class="literal">null</span> &amp;&amp; count &lt; index)</span><br><span class="line">            &#123;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 当索引超出链表长度时，返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> curNode.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtHead</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyLinkedNode addNode = <span class="keyword">new</span> MyLinkedNode();</span><br><span class="line">            addNode.val = val;</span><br><span class="line">            <span class="keyword">if</span> (StartHead.next == <span class="literal">null</span>)  <span class="comment">//我这里好像就弄反顺序了</span></span><br><span class="line">            &#123;</span><br><span class="line">                StartHead.next = addNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                addNode.next = StartHead.next.next;</span><br><span class="line">                StartHead.next = addNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtTail</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历找到尾部节点 从头节点开始</span></span><br><span class="line">            <span class="keyword">if</span> (StartHead.next == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//链表为空</span></span><br><span class="line">                StartHead.next = <span class="keyword">new</span> MyLinkedNode();</span><br><span class="line">                StartHead.next.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MyLinkedNode endNode = StartHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (endNode.next != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                endNode = endNode.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            endNode.next = <span class="keyword">new</span> MyLinkedNode();</span><br><span class="line">            endNode.next.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtIndex</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MyLinkedNode addNode = <span class="keyword">new</span> MyLinkedNode();</span><br><span class="line">            addNode.val = val;</span><br><span class="line"></span><br><span class="line">            MyLinkedNode curNode = StartHead;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode.next == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当索引超出链表长度时，将节点添加到链表末尾</span></span><br><span class="line">                    curNode.next = addNode;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 curNode 指向插入位置的前一个节点</span></span><br><span class="line">            addNode.next = curNode.next;</span><br><span class="line">            curNode.next = addNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// MyLinkedNode addNode = new MyLinkedNode();</span></span><br><span class="line">            <span class="comment">// addNode.val = val;</span></span><br><span class="line">            <span class="comment">// MyLinkedNode curNode = StartHead.next;</span></span><br><span class="line">            <span class="comment">// if(curNode == null)&#123;</span></span><br><span class="line">            <span class="comment">//     //如果头结点为空 链表为空</span></span><br><span class="line">            <span class="comment">//     StartHead.next = addNode;</span></span><br><span class="line">            <span class="comment">//     return;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// //头结点不为空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// //前一个节点</span></span><br><span class="line">            <span class="comment">// MyLinkedNode lastNode = StartHead;</span></span><br><span class="line">            <span class="comment">// while(index &gt; 0)&#123;</span></span><br><span class="line">            <span class="comment">//     if(curNode != null &amp;&amp; lastNode != null)&#123;</span></span><br><span class="line">            <span class="comment">//         lastNode = curNode;</span></span><br><span class="line">            <span class="comment">//         curNode = curNode.next;</span></span><br><span class="line">            <span class="comment">//     &#125;else if(curNode == null &amp;&amp; index == 0)&#123;</span></span><br><span class="line">            <span class="comment">//         //等于长度了</span></span><br><span class="line">            <span class="comment">//         lastNode.next = addNode;</span></span><br><span class="line">            <span class="comment">//         return;</span></span><br><span class="line">            <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//         return;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     index--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// //插入节点在这个节点之前</span></span><br><span class="line">            <span class="comment">// addNode.next = curNode;</span></span><br><span class="line">            <span class="comment">// lastNode.next = addNode;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteAtIndex</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MyLinkedNode curNode = StartHead;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode.next == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果索引超出链表长度，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 curNode 指向要删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (curNode.next != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curNode.next = curNode.next.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// MyLinkedNode curNode = StartHead.next;</span></span><br><span class="line">            <span class="comment">// MyLinkedNode beforeNode = StartHead.next;</span></span><br><span class="line">            <span class="comment">// if(curNode == null)&#123;</span></span><br><span class="line">            <span class="comment">//     return;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// while(index &gt; 0)&#123;</span></span><br><span class="line">            <span class="comment">//     if(curNode != null)&#123;</span></span><br><span class="line">            <span class="comment">//         beforeNode = curNode;</span></span><br><span class="line">            <span class="comment">//         curNode = curNode.next;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     else&#123;</span></span><br><span class="line">            <span class="comment">//         return;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     index--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// //删除这个节点 之前的节点断开</span></span><br><span class="line">            <span class="comment">// beforeNode.next = curNode.next;</span></span><br><span class="line">            <span class="comment">// curNode = null;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.Get(index);</span></span><br><span class="line"><span class="comment">     * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment">     * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment">     * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment">     * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>好 那写之前我决定看视频先学习一下</p><ol><li><p>获取第n个节点的值</p><ol><li>合法性判断 ： n&lt;0 且 n &gt; size-1 都是不合法的</li><li>定义临时指针 cur 为 dummyHead -&gt; next；</li><li>记住极端情况  获取第0个的情况</li></ol></li><li><p>头部插入节点</p><ol><li>new 一个新Node</li><li>new.next &#x3D; dummy .next (注意这里的顺序 如果和3反了 会导致连接错误)  </li><li>dummy.next &#x3D; new </li><li>size++</li></ol></li><li><p>尾部插入节点</p><ol><li>cur &#x3D; dummy</li><li>while(cur.next !&#x3D; null) 为空为终止条件</li><li>cur.next &#x3D; newNode</li></ol></li><li><p>第n个节点前插入节点</p><ol><li>cur &#x3D; dummy</li><li>while(n–){ cur &#x3D; cur.next} n为0 的时候 终止</li><li>和插入一样   如下图顺序</li><li><div class="img-item" data-src="/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/image-20240407212448058.png" data-sub-html=".caption"><img src="/2024/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/image-20240407212448058.png" class="" title="image-20240407212448058"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240407212448058</span></div></div></li></ol></li><li><p>删除第n个节点</p><ol><li>cur&#x3D; dummy</li><li>第n个节点一定要是 cur.next 然后我们操作第cur个节点</li><li>一样 while(n–) cur&#x3D; cur.next  第n个为 cur.next</li><li>cur.next &#x3D; cur.next.next; 指向下下个  为null也不要紧  n记得前面要防止极端条件</li><li>size–</li></ol></li></ol><p>好了 船新代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyLinkedNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> MyLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedNode</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyLinkedList</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//虚假头节点</span></span><br><span class="line">        <span class="keyword">public</span> MyLinkedNode StartHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            StartHead = <span class="keyword">new</span> MyLinkedNode(<span class="number">0</span>);</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不合法 </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;size <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//从头结点开始遍历</span></span><br><span class="line">            MyLinkedNode curNode = StartHead.next;</span><br><span class="line">            <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;  <span class="comment">//符合index==0的情况</span></span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> curNode.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtHead</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyLinkedNode addNode = <span class="keyword">new</span> MyLinkedNode(val);</span><br><span class="line">            <span class="comment">//先让新的指向 目标节点</span></span><br><span class="line">            addNode.next = StartHead.next;</span><br><span class="line">            StartHead.next = addNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtTail</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyLinkedNode addNode = <span class="keyword">new</span> MyLinkedNode(val);</span><br><span class="line">            <span class="comment">//找到末尾节点</span></span><br><span class="line">            MyLinkedNode curNode = StartHead;</span><br><span class="line">            <span class="keyword">while</span>(curNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.next = addNode;</span><br><span class="line">            size++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAtIndex</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">int</span> val</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不合法 </span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里如果小于零 不应该返回 而是插入头结点  </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到第n个节点</span></span><br><span class="line">            MyLinkedNode addNode = <span class="keyword">new</span> MyLinkedNode(val);</span><br><span class="line">            MyLinkedNode curNode = StartHead;</span><br><span class="line">            <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            addNode.next = curNode.next; <span class="comment">//添加的节点的下一个指向n个节点</span></span><br><span class="line">            curNode.next = addNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteAtIndex</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不合法 </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;size <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            MyLinkedNode curNode = StartHead;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.next = curNode.next.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.Get(index);</span></span><br><span class="line"><span class="comment">     * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment">     * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment">     * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment">     * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>要注意几个点 一个是 插入的时候 按照需求  index&lt;0  并不是不合法 而是 直接插入头结点 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-移除链表元素</title>
      <link href="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><blockquote><p>前言： 这题在4天前 差不多 4月2日我写了一次 所以相对更加熟悉了一些。画了两百个馒头进算法训练营，发现用C#的小伙伴真的好少啊，突然开始觉得自己又花冤枉钱了。而且同时要肝项目 还要刷算法 还想打游戏真的好难啊。项目上又遇到难关了。本来应该抽离出来的数据 一开始没考虑好抽离。现在复制黏贴功能不好弄咯。 下次不能犯这种错误了。</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><div class="img-item" data-src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" data-sub-html=".caption"><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">img</span></div></div></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul></blockquote><p>在两天前 我是没设定一个虚假的头结点的</p><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public ListNode next;</span></span><br><span class="line"><span class="comment"> *     public ListNode(int val=0, ListNode next=null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.next = next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="built_in">int</span> val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//移除头结点</span></span><br><span class="line">        <span class="keyword">while</span> ( head!=<span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            <span class="comment">//新的头结点向后移动</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode curNode;</span><br><span class="line">        ListNode preNode; <span class="comment">//上一个节点</span></span><br><span class="line">        preNode = head;</span><br><span class="line">        curNode = head.next; </span><br><span class="line">        <span class="comment">//非头节点 如果下一个节点不为空(不是末尾节点) 且当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(curNode.val == val)&#123;</span><br><span class="line">            <span class="comment">//上一个节点指向当前节点的下一个</span></span><br><span class="line">            preNode.next = curNode.next;</span><br><span class="line">            curNode = <span class="literal">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preNode = preNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           curNode = preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后 今天这个是设立了虚假头结点的</p><h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public ListNode next;</span></span><br><span class="line"><span class="comment"> *     public ListNode(int val=0, ListNode next=null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.next = next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">RemoveElements</span>(<span class="params">ListNode head, <span class="built_in">int</span> val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个虚拟头结点 StartNode.next 为头结点</span></span><br><span class="line">        ListNode StartNode = <span class="keyword">new</span>();</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        ListNode LastNode = StartNode;</span><br><span class="line">        StartNode.next = head;</span><br><span class="line">        <span class="comment">//如果移除的是头结点</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            StartNode.next = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StartNode.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> StartNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curNode.val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                LastNode.next = curNode.next;</span><br><span class="line">                curNode = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LastNode = LastNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里关键要注意一下 当前节点始终在前一个节点的下一个</span></span><br><span class="line">            curNode = LastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StartNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯</p><p>所以说 上一个节点 是命名为 <code>preNode</code> 好 还是 <code>lastNode</code>好呢 </p><p>好纠结</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KooFrame-代码生成器</title>
      <link href="/2024/04/06/%E5%85%B3%E4%BA%8EKooFrame%E7%9A%84%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%83%B3%E6%B3%95%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/04/06/%E5%85%B3%E4%BA%8EKooFrame%E7%9A%84%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%83%B3%E6%B3%95%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="关于KooFrame的基础-代码生成器的想法构建"><a href="#关于KooFrame的基础-代码生成器的想法构建" class="headerlink" title="关于KooFrame的基础-代码生成器的想法构建"></a>关于KooFrame的基础-代码生成器的想法构建</h1><blockquote><p>前言 :  我一直在思考自己的毕设在做什么，一个简简单单的游戏？ 一款完全可能根本就没有人会能玩到的残次品？。在有限的时间 用Unity做一段美术流程的动画来展示自己技术美术相关的能力？ 但以我目前的技术面来说，我打算就Editor方面出发，编写一套适合引导学生学习的Unity架构</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Unity架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-螺旋矩阵</title>
      <link href="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><blockquote><p>前言 ： 果然这题目又告诉我，你的逻辑推理能力太差了，我自己写的时候，转圈真给自己转进去了，哎。</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><div class="img-item" data-src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" data-sub-html=".caption"><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">img</span></div></div></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul></blockquote><p>这题主要在于模拟过程，知道应该要左闭右开 每个节点末尾留给下一次循环遍历来处理就好。然后难点就在要注意每转一圈之后 都有一个+1的偏移量 和 奇偶数 最后的处理了</p><div class="img-item" data-src="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20240406030020682.png" data-sub-html=".caption"><img src="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20240406030020682.png" class="" title="image-20240406030020682"></div><p>这里画一个偶数的情况</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] GenerateMatrix(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//生成从1 到 n2的数组</span></span><br><span class="line">        <span class="built_in">int</span> n2 = n * n;</span><br><span class="line">        <span class="built_in">int</span>[][] result = <span class="keyword">new</span> <span class="built_in">int</span>[n][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> a= <span class="number">0</span>;a&lt;n;a++)&#123;</span><br><span class="line">            result[a] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> startx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> starty = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个螺旋矩阵是n*n的 第一圈是[0,n)</span></span><br><span class="line">        <span class="built_in">int</span> loop = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = startx;</span><br><span class="line">            i = starty;</span><br><span class="line">            <span class="comment">// 第一条边左闭右开填充</span></span><br><span class="line">            <span class="keyword">for</span>(i =starty;i&lt; n-offset;i++)&#123;</span><br><span class="line">                result[startx][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二条边</span></span><br><span class="line">            <span class="keyword">for</span>(j= startx;j &lt; n- offset;j++)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;starty;i--)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第四条边</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;startx;j--)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后处理奇数</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下</p><p>这种模拟过程 对于一些 在游戏逻辑中 就比如转圈圈放东西 这种逻辑来说还是非常有必要的。 实际情况可能就是一个List 然后要在一个二维数组里 比如地图网格 螺旋放物品。 这种情况 也许 可能会出现。 如果出现 那我就愉快的用这个来写了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-长度最小的子数组</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><blockquote><p>前言：这题也算是中等题目 我次次做次次错 ，我自然是知道自己的坏习惯的 每次隔个几个月就暗暗下定决心刷算法。然后每次都是从一开始写就感到挫折。一道题写半天还是错啊，一道题想一天还是没思路啊 巴拉巴拉。不知不觉 大部分业务都能写了，结果算法还是一窍不通。自感悲哀</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续</strong></p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul></blockquote><p>解法1 暴力解法：</p><p>我的解答：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="built_in">int</span> target, <span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="built_in">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;nums.Length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((j - i)+<span class="number">1</span> &lt;= result)</span><br><span class="line">                    result = (j - i)+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="built_in">int</span>.MaxValue? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为力扣已经不让用这种方法去解答了 会超时</p><p>但这样写应该是能符合需求的</p><p>标准答案C++的暴力循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>答案的写法 可读性和性能肯定比我的好</p><p>好了 上面都是没啥用的 因为这题要用滑动窗口去写 </p><p>示例图：</p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" class="" title="209.长度最小的子数组"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">209.长度最小的子数组</span></div></div><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="built_in">int</span> target, <span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>; <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>; <span class="comment">//滑动窗口终止位置  这里注意 j是循环完一次数组的</span></span><br><span class="line">        <span class="built_in">int</span> subSize = <span class="number">0</span>; <span class="comment">//窗口长度</span></span><br><span class="line">        <span class="built_in">int</span> result = <span class="built_in">int</span>.MaxValue; <span class="comment">//依旧是结果从最大值取起</span></span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>; <span class="comment">//总和 这里注意不要放内部计算 在循环内部会加加减减</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.Length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="comment">//计算窗口长度</span></span><br><span class="line">                subSize = j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断一下结果与窗口长度 如果结果小于窗口 不赋值 为最大值 </span></span><br><span class="line">                result = result &lt; subSize? result :subSize;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                <span class="comment">//起始位置前移</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == <span class="built_in">int</span>.MaxValue? <span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说一个可笑的小插曲</p><p>我注意一下如果换成 <code>result = result &lt; subSize? result :subSize;</code> 这句 其实一样 但我写题的时候纠结很久  因为我当时纠结的地方错了  我以外如果判断顺序反了 比如写成 result &#x3D; subSize&lt; result ? subSize :result ; 我想 result就不可能为int.MaxValue 那如何有让result保持初始值的情况呢。其实是我忽略了while中的判断条件 如果while根本不进入 那result就会一直保持初始值。这里只是我想错了导致的无意义纠结。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-有序数组平方</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><blockquote><p>前言 ： 这题算是第二次写了 记的还是比较清楚的 第一次写肯定想着暴力写法 先平方再排序 后面想明白了就知道 从两边开始比较  因为这个数组是<strong>有序的</strong> 大的一定在两边 所以新的数组从两边开始</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">SortedSquares</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//从两头开始 </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[nums.Length];</span><br><span class="line">        <span class="built_in">int</span> size = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//当左指针不再小于右指针的时候 不再循环</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//如果左平方大于右平方</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                result[size] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[size] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里叭叭一下 我写题的心路历程吧 因为是写过的 所以知道从两头开始算 但奈何还是犯傻了 size居然从0开始  因为两边必然有一方是最大的 所以 肯定啊 新数组从右边开始填充就是错的啊 结果会变成 直接平方的顺序啦。</p><p>这里我感觉还能优化一下空间复杂度 不需要有一个新的数组 直接覆盖试试 </p><p>好嘞 虽然时间不够 但试试看</p><p>（你要时间多也不会花小半天弄没用的博客。。。工作还做不做了？）</p><p>（QwQ 我是真把自己当黑奴了啊）</p><p>然后就有了下面的想法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">SortedSquares</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//从两头开始 </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int[] result = new int[nums.Length];</span></span><br><span class="line">        <span class="built_in">int</span> size = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//当左指针不再小于右指针的时候 不再循环</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//如果左平方大于右平方 这时候右边会被覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                nums[size] = nums[left] * nums[left];</span><br><span class="line">                size--;</span><br><span class="line">                nums[size] = nums[right] * nums[right];</span><br><span class="line">                size--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//右边大于左边 这时候不会被覆盖</span></span><br><span class="line">                nums[size] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好  very good</p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/image-20240405143814891.png" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/image-20240405143814891.png" class="" title="image-20240405143814891"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405143814891</span></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity节点编辑器制作的流程记录</title>
      <link href="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity节点编辑器"><a href="#Unity节点编辑器" class="headerlink" title="Unity节点编辑器"></a>Unity节点编辑器</h1><blockquote><p>前言： 狂怒传说 项目中 因为想要做一个泛用的对话树 对话树还要被大行为树包起来？ 好好好  小小NPC必须好好捣鼓一下  这下好了 不得不手搓行为树了</p></blockquote><div class="img-item" data-src="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20240405034841452.png" data-sub-html=".caption"><img src="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20240405034841452.png" class="" title="image-20240405034841452"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405034841452</span></div></div><p>如何让Assets跟Hierarchy之间进行序列化的存储可难倒我了  这里 就要弄清楚 GameObject 在 Scene Assets 中的区别了 </p><p>考虑到效率 我打算先临时用一个 Hash值来 表示数据Data </p><p>节点保存int的哈希值，然后每次选中节点的时候 根据哈希值和当前树的拥有者来通过Linq查找 List集合中的数据Data</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//****************** 代码文件申明 ************************</span></span><br><span class="line"><span class="comment">//* 文件：NodeDataInOwner                                       </span></span><br><span class="line"><span class="comment">//* 作者：Koo</span></span><br><span class="line"><span class="comment">//* 创建时间：2024/04/04 00:08:02 星期四</span></span><br><span class="line"><span class="comment">//* 功能：nothing</span></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> KooFrame;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NodeDataInOwner</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//public Dictionary&lt;string, MethodInfo&gt; methodsDic = new();</span></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField, HideInInspector</span>] <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; methodsTypeNames = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> UnityEvent Event = <span class="keyword">new</span> UnityEvent();</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 运行时 会根据这个名字 对Event加委托监听</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">string</span> CurRegisterMethodName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">int</span> OwnerDataID;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> TreeOwner Owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> GameObject EventTrigger;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 绑定的Node</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> Node BindNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeDataInOwner</span>(<span class="params">Node node, TreeOwner owner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            BindNode = node;</span><br><span class="line">            Owner = owner;</span><br><span class="line">            OwnerDataID = Animator.StringToHash(owner.name +</span><br><span class="line">                                                (owner.NodeDatas.Count)</span><br><span class="line">                                                .ToString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EventAddListener</span>(<span class="params">MethodInfo methodInfo, Type invokeObj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            UnityAction methodDelegate = () =&gt;</span><br><span class="line">                methodInfo.Invoke(</span><br><span class="line">                    EventTrigger.GetComponent(invokeObj), <span class="literal">null</span>);</span><br><span class="line">            CurRegisterMethodName = invokeObj.FullName + <span class="string">&quot;/&quot;</span> + methodInfo.Name;</span><br><span class="line">            Event.AddListener(methodDelegate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来一个问题就出现了 我序列化了要触发方法的名字 这里我如何通过名字拿到方法的委托来用来注册到事件里面去呢。</p><p>通过对象 和对象的Component名称 和当中的方法名称 在OnEnable的时候 反射拿到方法 并注册进事件当中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注册事件</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> nodeDataInOwner <span class="keyword">in</span> NodeDatas)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[] typeAndmethod = nodeDataInOwner.CurRegisterMethodName.Split(<span class="string">&quot;/&quot;</span>, StringSplitOptions.None);</span><br><span class="line">                <span class="comment">//得到方法</span></span><br><span class="line">                Type type = nodeDataInOwner.EventTrigger.GetComponent(Type.GetType(typeAndmethod[<span class="number">0</span>])).GetType();</span><br><span class="line">                <span class="comment">//获得所有方法 这里限制了方法必须是公共的 实例方法 而非静态或者字段</span></span><br><span class="line">                MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance);</span><br><span class="line">                MethodInfo method = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> methodInfo <span class="keyword">in</span> methods)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果是Void返回值 并且无参 名称相同</span></span><br><span class="line">                    <span class="keyword">if</span> (methodInfo.ReturnType == <span class="keyword">typeof</span>(<span class="keyword">void</span>) &amp;&amp; methodInfo.GetParameters().Length == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        methodInfo.Name == typeAndmethod[<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        method = methodInfo;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                UnityAction action = () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method != <span class="literal">null</span>) method.Invoke(nodeDataInOwner.EventTrigger.GetComponent(type), <span class="literal">null</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                nodeDataInOwner.Event.AddListener(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里的流程应该还能优化一些 让OnEnable可以执行的更快</p><p>0406</p><p>今天制作节点编辑器遇到了很多困难 比较触碰到了那个实验性的基类的属性 而且又是我知识盲区。</p><p>第一个是 节点没办法根据鼠标位置来创建 </p><p>​第一个完全是坐标系的转换很出问题  就仿佛是之前在Scene窗口 右键移动GO一样 </p><p> 转换不同坐标系是很麻烦的一件事</p><p>第二个则是 节点的复制和黏贴  </p><p>   这里则是Node的数据层没有很好的剥离开来。导致需要序列化的时候。 没办法转换成能方便复制黏贴的json格式。</p><p>这里我想只有两种解决办法 </p><ol><li>自己定义string化的格式和内容，只抽离出必要的数据。来完成复制和黏贴</li><li>新写出可序列化的数据类NodeModel，复制的时候json化Model类 同理 黏贴的时候反序列化一下</li></ol><p>不过我也在油管上找到了合适的教程 ，可是demo时间紧任务重 。 果然还是先快点完成比较好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UnityEditor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-移除元素</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><blockquote><p>前言： 简单题暴打我 3年后归来还是被直接KO 我还真是算法白痴 有人愿意花3小时学算法 但我宁愿花三小时玩博客 真是丢西瓜。。。</p></blockquote><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul></blockquote><h3 id="题解过程"><a href="#题解过程" class="headerlink" title="题解过程"></a>题解过程</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RemoveElement</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//这是两次遍历的暴力解法 </span></span><br><span class="line">        <span class="comment">// int size = nums.Length;</span></span><br><span class="line">        <span class="comment">// for(int i = 0;i&lt;size;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[i] == val)&#123;</span></span><br><span class="line">        <span class="comment">//         //后面都往前移动</span></span><br><span class="line">        <span class="comment">//         for(int j = i+1;j&lt;size;j++)&#123;</span></span><br><span class="line">        <span class="comment">//             nums[j-1] = nums[j];</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         i--;  //我失败就失败在又漏了i-- 数组变化了 你i不变化？ </span></span><br><span class="line">        <span class="comment">//         size--; </span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return size;</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//快慢指针法 这里是答案写法 我写的烂透了 这里写的真精简啊..</span></span><br><span class="line">        <span class="built_in">int</span> slowPoint = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> fastPoint=<span class="number">0</span>;fastPoint&lt;nums.Length;fastPoint++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPoint] != val)&#123;</span><br><span class="line">                nums[slowPoint++] = nums[fastPoint];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>简单的说 就是 数组是不能删掉的  数组内的元素都是覆盖的 大概内部有个计数器用来标记长度 加加减减</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><blockquote><p>快慢指针通常用来解决这些问题：</p><ol><li>判断链表是否有环：快指针以比慢指针更快的速度遍历链表，如果链表中有环，快指针最终会追上慢指针，从而发现环的存在。</li><li>寻找链表的中间节点：慢指针每次移动一步，快指针每次移动两步，当快指针到达链表末尾时，慢指针指向的节点即为中间节点。</li></ol></blockquote><p>也许能在实践中用到？  但<code>LinkList</code>这种结构都使用极少……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-二分查找</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>前言：这道题  真的可是说我做了很多遍 就仿佛如英语的abandon 仿佛如恶魔的低语一般伴随着我不会算法的日子。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li></ol></blockquote><p>二分又叫分治法 主要要点在于分而治之 </p><p><strong>关键在于分治时候的区间范围取值</strong></p><p>版本一 左闭右闭版本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义区间范围为 [left,right] </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length <span class="number">-1</span>; </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">//因为是闭合区间 才能取到等号</span></span><br><span class="line">            <span class="comment">//这里做减法 防止溢出</span></span><br><span class="line">            <span class="built_in">int</span> middle = left + (-left + right) /<span class="number">2</span>; </span><br><span class="line">            <span class="comment">//目标一定在左边 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) </span><br><span class="line">            &#123; <span class="comment">//范围变成左闭右闭 [left,middle-1]</span></span><br><span class="line">                right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//目标在右边</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                <span class="comment">//范围变成 [middle+1,right]</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二 左闭右开</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义区间范围为 [left,right)</span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length; </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//因为不是闭合区间 不取等号了</span></span><br><span class="line">            <span class="comment">//这里做减法 防止溢出</span></span><br><span class="line">            <span class="comment">//高级写法 &gt;&gt; 运算符是右移位运算符 它将 right - left 的结果右移一位，相当于将其除以2 逆天写法 平常感觉用不太到 学不太来</span></span><br><span class="line">             <span class="built_in">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//目标一定在左边 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) </span><br><span class="line">            &#123; <span class="comment">//不是上版的 middle-1了 范围变成左闭右闭 [left,middle)</span></span><br><span class="line">                right = middle;  </span><br><span class="line">            <span class="comment">//目标在右边</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                <span class="comment">//范围变成 [middle+1,right)</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运用分析"><a href="#运用分析" class="headerlink" title="运用分析"></a>运用分析</h1><p>二分查找我认为是学习 循环中判断与开闭区间关系的一道好题目 </p><p>实际项目中没有用到过   </p><p>叭叭两句 <code>&gt;&gt;</code> 这个玩意 GPT告送我 大多数情况 替换 &#x2F;2 是安全的 但真的会有人这样用吗 这样可读性就下降了 可能性能有微小的提升吧 注意的是 右移运算不会出现小数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> c = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用右移位运算符</span></span><br><span class="line"><span class="built_in">int</span> result1 = c &gt;&gt; <span class="number">1</span>;  <span class="comment">// 结果为 -3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用除法</span></span><br><span class="line"><span class="built_in">int</span> result2 = c / <span class="number">2</span>;   <span class="comment">// 结果为 -2</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;结果1: &quot;</span> + result1);  <span class="comment">// 输出-3</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;结果2: &quot;</span> + result2);  <span class="comment">// 输出-2</span></span><br></pre></td></tr></table></figure><p>运行一下 不一样  感觉有点危险 能少用还是少用吧 </p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240405014738787.png" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240405014738787.png" class="" title="image-20240405014738787"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405014738787</span></div></div><p>我写好多次 每次写二分还是废 所白了 就是记不住 写这篇文章 就是要逼我 强行记住 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

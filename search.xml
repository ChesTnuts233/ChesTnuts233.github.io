<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KooFrame-代码生成器</title>
      <link href="/2024/04/06/%E5%85%B3%E4%BA%8EKooFrame%E7%9A%84%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%83%B3%E6%B3%95%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/04/06/%E5%85%B3%E4%BA%8EKooFrame%E7%9A%84%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%83%B3%E6%B3%95%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="关于KooFrame的基础-代码生成器的想法构建"><a href="#关于KooFrame的基础-代码生成器的想法构建" class="headerlink" title="关于KooFrame的基础-代码生成器的想法构建"></a>关于KooFrame的基础-代码生成器的想法构建</h1><blockquote><p>前言 :  我一直在思考自己的毕设在做什么，一个简简单单的游戏？ 一款完全可能根本就没有人会能玩到的残次品？。在有限的时间 用Unity做一段美术流程的动画来展示自己技术美术相关的能力？ 但以我目前的技术面来说，我打算就Editor方面出发，编写一套适合引导学生学习的Unity架构</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Unity架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-螺旋矩阵</title>
      <link href="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><blockquote><p>前言 ： 果然这题目又告诉我，你的逻辑推理能力太差了，我自己写的时候，转圈真给自己转进去了，哎。</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><div class="img-item" data-src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" data-sub-html=".caption"><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">img</span></div></div></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul></blockquote><p>这题主要在于模拟过程，知道应该要左闭右开 每个节点末尾留给下一次循环遍历来处理就好。然后难点就在要注意每转一圈之后 都有一个+1的偏移量 和 奇偶数 最后的处理了</p><div class="img-item" data-src="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20240406030020682.png" data-sub-html=".caption"><img src="/2024/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20240406030020682.png" class="" title="image-20240406030020682"></div><p>这里画一个偶数的情况</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] GenerateMatrix(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//生成从1 到 n2的数组</span></span><br><span class="line">        <span class="built_in">int</span> n2 = n * n;</span><br><span class="line">        <span class="built_in">int</span>[][] result = <span class="keyword">new</span> <span class="built_in">int</span>[n][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> a= <span class="number">0</span>;a&lt;n;a++)&#123;</span><br><span class="line">            result[a] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> startx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> starty = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个螺旋矩阵是n*n的 第一圈是[0,n)</span></span><br><span class="line">        <span class="built_in">int</span> loop = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = startx;</span><br><span class="line">            i = starty;</span><br><span class="line">            <span class="comment">// 第一条边左闭右开填充</span></span><br><span class="line">            <span class="keyword">for</span>(i =starty;i&lt; n-offset;i++)&#123;</span><br><span class="line">                result[startx][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二条边</span></span><br><span class="line">            <span class="keyword">for</span>(j= startx;j &lt; n- offset;j++)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;starty;i--)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第四条边</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;startx;j--)&#123;</span><br><span class="line">                result[j][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后处理奇数</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下</p><p>这种模拟过程 对于一些 在游戏逻辑中 就比如转圈圈放东西 这种逻辑来说还是非常有必要的。 实际情况可能就是一个List 然后要在一个二维数组里 比如地图网格 螺旋放物品。 这种情况 也许 可能会出现。 如果出现 那我就愉快的用这个来写了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-长度最小的子数组</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><blockquote><p>前言：这题也算是中等题目 我次次做次次错 ，我自然是知道自己的坏习惯的 每次隔个几个月就暗暗下定决心刷算法。然后每次都是从一开始写就感到挫折。一道题写半天还是错啊，一道题想一天还是没思路啊 巴拉巴拉。不知不觉 大部分业务都能写了，结果算法还是一窍不通。自感悲哀</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续</strong></p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul></blockquote><p>解法1 暴力解法：</p><p>我的解答：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="built_in">int</span> target, <span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="built_in">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;nums.Length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((j - i)+<span class="number">1</span> &lt;= result)</span><br><span class="line">                    result = (j - i)+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="built_in">int</span>.MaxValue? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为力扣已经不让用这种方法去解答了 会超时</p><p>但这样写应该是能符合需求的</p><p>标准答案C++的暴力循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>答案的写法 可读性和性能肯定比我的好</p><p>好了 上面都是没啥用的 因为这题要用滑动窗口去写 </p><p>示例图：</p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" class="" title="209.长度最小的子数组"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">209.长度最小的子数组</span></div></div><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="built_in">int</span> target, <span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>; <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>; <span class="comment">//滑动窗口终止位置  这里注意 j是循环完一次数组的</span></span><br><span class="line">        <span class="built_in">int</span> subSize = <span class="number">0</span>; <span class="comment">//窗口长度</span></span><br><span class="line">        <span class="built_in">int</span> result = <span class="built_in">int</span>.MaxValue; <span class="comment">//依旧是结果从最大值取起</span></span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>; <span class="comment">//总和 这里注意不要放内部计算 在循环内部会加加减减</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.Length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="comment">//计算窗口长度</span></span><br><span class="line">                subSize = j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断一下结果与窗口长度 如果结果小于窗口 不赋值 为最大值 </span></span><br><span class="line">                result = result &lt; subSize? result :subSize;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                <span class="comment">//起始位置前移</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == <span class="built_in">int</span>.MaxValue? <span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说一个可笑的小插曲</p><p>我注意一下如果换成 <code>result = result &lt; subSize? result :subSize;</code> 这句 其实一样 但我写题的时候纠结很久  因为我当时纠结的地方错了  我以外如果判断顺序反了 比如写成 result &#x3D; subSize&lt; result ? subSize :result ; 我想 result就不可能为int.MaxValue 那如何有让result保持初始值的情况呢。其实是我忽略了while中的判断条件 如果while根本不进入 那result就会一直保持初始值。这里只是我想错了导致的无意义纠结。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-有序数组平方</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><blockquote><p>前言 ： 这题算是第二次写了 记的还是比较清楚的 第一次写肯定想着暴力写法 先平方再排序 后面想明白了就知道 从两边开始比较  因为这个数组是<strong>有序的</strong> 大的一定在两边 所以新的数组从两边开始</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">SortedSquares</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//从两头开始 </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[nums.Length];</span><br><span class="line">        <span class="built_in">int</span> size = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//当左指针不再小于右指针的时候 不再循环</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//如果左平方大于右平方</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                result[size] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[size] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里叭叭一下 我写题的心路历程吧 因为是写过的 所以知道从两头开始算 但奈何还是犯傻了 size居然从0开始  因为两边必然有一方是最大的 所以 肯定啊 新数组从右边开始填充就是错的啊 结果会变成 直接平方的顺序啦。</p><p>这里我感觉还能优化一下空间复杂度 不需要有一个新的数组 直接覆盖试试 </p><p>好嘞 虽然时间不够 但试试看</p><p>（你要时间多也不会花小半天弄没用的博客。。。工作还做不做了？）</p><p>（QwQ 我是真把自己当黑奴了啊）</p><p>然后就有了下面的想法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">SortedSquares</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//从两头开始 </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int[] result = new int[nums.Length];</span></span><br><span class="line">        <span class="built_in">int</span> size = nums.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//当左指针不再小于右指针的时候 不再循环</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//如果左平方大于右平方 这时候右边会被覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                nums[size] = nums[left] * nums[left];</span><br><span class="line">                size--;</span><br><span class="line">                nums[size] = nums[right] * nums[right];</span><br><span class="line">                size--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//右边大于左边 这时候不会被覆盖</span></span><br><span class="line">                nums[size] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好  very good</p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/image-20240405143814891.png" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%B9%B3%E6%96%B9/image-20240405143814891.png" class="" title="image-20240405143814891"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405143814891</span></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity节点编辑器制作的流程记录</title>
      <link href="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity节点编辑器"><a href="#Unity节点编辑器" class="headerlink" title="Unity节点编辑器"></a>Unity节点编辑器</h1><blockquote><p>前言： 狂怒传说 项目中 因为想要做一个泛用的对话树 对话树还要被大行为树包起来？ 好好好  小小NPC必须好好捣鼓一下  这下好了 不得不手搓行为树了</p></blockquote><div class="img-item" data-src="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20240405034841452.png" data-sub-html=".caption"><img src="/2024/04/05/Unity%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%88%B6%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20240405034841452.png" class="" title="image-20240405034841452"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405034841452</span></div></div><p>如何让Assets跟Hierarchy之间进行序列化的存储可难倒我了  这里 就要弄清楚 GameObject 在 Scene Assets 中的区别了 </p><p>考虑到效率 我打算先临时用一个 Hash值来 表示数据Data </p><p>节点保存int的哈希值，然后每次选中节点的时候 根据哈希值和当前树的拥有者来通过Linq查找 List集合中的数据Data</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//****************** 代码文件申明 ************************</span></span><br><span class="line"><span class="comment">//* 文件：NodeDataInOwner                                       </span></span><br><span class="line"><span class="comment">//* 作者：Koo</span></span><br><span class="line"><span class="comment">//* 创建时间：2024/04/04 00:08:02 星期四</span></span><br><span class="line"><span class="comment">//* 功能：nothing</span></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> KooFrame;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NodeDataInOwner</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//public Dictionary&lt;string, MethodInfo&gt; methodsDic = new();</span></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField, HideInInspector</span>] <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; methodsTypeNames = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> UnityEvent Event = <span class="keyword">new</span> UnityEvent();</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 运行时 会根据这个名字 对Event加委托监听</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">string</span> CurRegisterMethodName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">int</span> OwnerDataID;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> TreeOwner Owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> GameObject EventTrigger;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 绑定的Node</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="keyword">public</span> Node BindNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeDataInOwner</span>(<span class="params">Node node, TreeOwner owner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            BindNode = node;</span><br><span class="line">            Owner = owner;</span><br><span class="line">            OwnerDataID = Animator.StringToHash(owner.name +</span><br><span class="line">                                                (owner.NodeDatas.Count)</span><br><span class="line">                                                .ToString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EventAddListener</span>(<span class="params">MethodInfo methodInfo, Type invokeObj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            UnityAction methodDelegate = () =&gt;</span><br><span class="line">                methodInfo.Invoke(</span><br><span class="line">                    EventTrigger.GetComponent(invokeObj), <span class="literal">null</span>);</span><br><span class="line">            CurRegisterMethodName = invokeObj.FullName + <span class="string">&quot;/&quot;</span> + methodInfo.Name;</span><br><span class="line">            Event.AddListener(methodDelegate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来一个问题就出现了 我序列化了要触发方法的名字 这里我如何通过名字拿到方法的委托来用来注册到事件里面去呢。</p><p>通过对象 和对象的Component名称 和当中的方法名称 在OnEnable的时候 反射拿到方法 并注册进事件当中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注册事件</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> nodeDataInOwner <span class="keyword">in</span> NodeDatas)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[] typeAndmethod = nodeDataInOwner.CurRegisterMethodName.Split(<span class="string">&quot;/&quot;</span>, StringSplitOptions.None);</span><br><span class="line">                <span class="comment">//得到方法</span></span><br><span class="line">                Type type = nodeDataInOwner.EventTrigger.GetComponent(Type.GetType(typeAndmethod[<span class="number">0</span>])).GetType();</span><br><span class="line">                <span class="comment">//获得所有方法 这里限制了方法必须是公共的 实例方法 而非静态或者字段</span></span><br><span class="line">                MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance);</span><br><span class="line">                MethodInfo method = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> methodInfo <span class="keyword">in</span> methods)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果是Void返回值 并且无参 名称相同</span></span><br><span class="line">                    <span class="keyword">if</span> (methodInfo.ReturnType == <span class="keyword">typeof</span>(<span class="keyword">void</span>) &amp;&amp; methodInfo.GetParameters().Length == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        methodInfo.Name == typeAndmethod[<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        method = methodInfo;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                UnityAction action = () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method != <span class="literal">null</span>) method.Invoke(nodeDataInOwner.EventTrigger.GetComponent(type), <span class="literal">null</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                nodeDataInOwner.Event.AddListener(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里的流程应该还能优化一些 让OnEnable可以执行的更快</p>]]></content>
      
      
      
        <tags>
            
            <tag> UnityEditor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-移除元素</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><blockquote><p>前言： 简单题暴打我 3年后归来还是被直接KO 我还真是算法白痴 有人愿意花3小时学算法 但我宁愿花三小时玩博客 真是丢西瓜。。。</p></blockquote><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul></blockquote><h3 id="题解过程"><a href="#题解过程" class="headerlink" title="题解过程"></a>题解过程</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RemoveElement</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//这是两次遍历的暴力解法 </span></span><br><span class="line">        <span class="comment">// int size = nums.Length;</span></span><br><span class="line">        <span class="comment">// for(int i = 0;i&lt;size;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[i] == val)&#123;</span></span><br><span class="line">        <span class="comment">//         //后面都往前移动</span></span><br><span class="line">        <span class="comment">//         for(int j = i+1;j&lt;size;j++)&#123;</span></span><br><span class="line">        <span class="comment">//             nums[j-1] = nums[j];</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         i--;  //我失败就失败在又漏了i-- 数组变化了 你i不变化？ </span></span><br><span class="line">        <span class="comment">//         size--; </span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return size;</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//快慢指针法 这里是答案写法 我写的烂透了 这里写的真精简啊..</span></span><br><span class="line">        <span class="built_in">int</span> slowPoint = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> fastPoint=<span class="number">0</span>;fastPoint&lt;nums.Length;fastPoint++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPoint] != val)&#123;</span><br><span class="line">                nums[slowPoint++] = nums[fastPoint];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>简单的说 就是 数组是不能删掉的  数组内的元素都是覆盖的 大概内部有个计数器用来标记长度 加加减减</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><blockquote><p>快慢指针通常用来解决这些问题：</p><ol><li>判断链表是否有环：快指针以比慢指针更快的速度遍历链表，如果链表中有环，快指针最终会追上慢指针，从而发现环的存在。</li><li>寻找链表的中间节点：慢指针每次移动一步，快指针每次移动两步，当快指针到达链表末尾时，慢指针指向的节点即为中间节点。</li></ol></blockquote><p>也许能在实践中用到？  但<code>LinkList</code>这种结构都使用极少……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-二分查找</title>
      <link href="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>前言：这道题  真的可是说我做了很多遍 就仿佛如英语的abandon 仿佛如恶魔的低语一般伴随着我不会算法的日子。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li></ol></blockquote><p>二分又叫分治法 主要要点在于分而治之 </p><p><strong>关键在于分治时候的区间范围取值</strong></p><p>版本一 左闭右闭版本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义区间范围为 [left,right] </span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length <span class="number">-1</span>; </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">//因为是闭合区间 才能取到等号</span></span><br><span class="line">            <span class="comment">//这里做减法 防止溢出</span></span><br><span class="line">            <span class="built_in">int</span> middle = left + (-left + right) /<span class="number">2</span>; </span><br><span class="line">            <span class="comment">//目标一定在左边 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) </span><br><span class="line">            &#123; <span class="comment">//范围变成左闭右闭 [left,middle-1]</span></span><br><span class="line">                right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//目标在右边</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                <span class="comment">//范围变成 [middle+1,right]</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二 左闭右开</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义区间范围为 [left,right)</span></span><br><span class="line">        <span class="built_in">int</span> right = nums.Length; </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//因为不是闭合区间 不取等号了</span></span><br><span class="line">            <span class="comment">//这里做减法 防止溢出</span></span><br><span class="line">            <span class="comment">//高级写法 &gt;&gt; 运算符是右移位运算符 它将 right - left 的结果右移一位，相当于将其除以2 逆天写法 平常感觉用不太到 学不太来</span></span><br><span class="line">             <span class="built_in">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//目标一定在左边 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) </span><br><span class="line">            &#123; <span class="comment">//不是上版的 middle-1了 范围变成左闭右闭 [left,middle)</span></span><br><span class="line">                right = middle;  </span><br><span class="line">            <span class="comment">//目标在右边</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                <span class="comment">//范围变成 [middle+1,right)</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运用分析"><a href="#运用分析" class="headerlink" title="运用分析"></a>运用分析</h1><p>二分查找我认为是学习 循环中判断与开闭区间关系的一道好题目 </p><p>实际项目中没有用到过   </p><p>叭叭两句 <code>&gt;&gt;</code> 这个玩意 GPT告送我 大多数情况 替换 &#x2F;2 是安全的 但真的会有人这样用吗 这样可读性就下降了 可能性能有微小的提升吧 注意的是 右移运算不会出现小数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> c = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用右移位运算符</span></span><br><span class="line"><span class="built_in">int</span> result1 = c &gt;&gt; <span class="number">1</span>;  <span class="comment">// 结果为 -3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用除法</span></span><br><span class="line"><span class="built_in">int</span> result2 = c / <span class="number">2</span>;   <span class="comment">// 结果为 -2</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;结果1: &quot;</span> + result1);  <span class="comment">// 输出-3</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;结果2: &quot;</span> + result2);  <span class="comment">// 输出-2</span></span><br></pre></td></tr></table></figure><p>运行一下 不一样  感觉有点危险 能少用还是少用吧 </p><div class="img-item" data-src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240405014738787.png" data-sub-html=".caption"><img src="/2024/04/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240405014738787.png" class="" title="image-20240405014738787"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">image-20240405014738787</span></div></div><p>我写好多次 每次写二分还是废 所白了 就是记不住 写这篇文章 就是要逼我 强行记住 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
